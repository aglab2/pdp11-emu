HALT ;dont remove me!

;pusha
MOV R0, -(SP)
MOV R1, -(SP)
MOV R2, -(SP)
MOV R3, -(SP)
MOV R4, -(SP)
MOV R5, -(SP)

MOV 14(SP), R5
ADD #76, R5
MOV #0, R3
MOV #0, R4
JSR PC, Sstart

;popa
MOV (SP)+, R5
MOV (SP)+, R4
MOV (SP)+, R3
MOV (SP)+, R2
MOV (SP)+, R1
MOV (SP)+, R0
ADD #2, SP

RTI

;subroutine	: Print Symbol to vram
;call		: JSR PC, Sstart
;arguments	: R3: x in 0..31(037) (word align), R4: y in 0..15(017) (letter height align), R5: letter code in ASCII
;destroyed	: R0, R1, R2
;changed	: R3 and R4 are changed to next symbol to print, so you can chain routines
Sstart:	MOV R5, R2
	SUB #41, R2		;first 33(041) ASCII symbols are skipped
	ASH #5, R2		;R2=R2*32 -- skip R2 symbols, one symbol is 32 bytes
	ADD #140000, R2		;fonts start

	MOV R4, R0
	ASH #12, R0		;TODO: why does this work????? (256*16)*y
	ADD R3, R0		
	ADD R3, R0		;4096*y+2*x is start of vram where letter is
	ADD #40000, R0		;vram start

;Next step is loading symbol onto the right place
;Symbol length width is 8 pixel = 16 bits = 1 word
;That is why after writing one word, we should move to another line that
;is placed in 256/4=64 bytes. Symbol takes 16 words
	MOV #20, R1		;We should load 16(020) words in vram
Sfor:	MOV (R2)+, (R0)		;write word to vram = 1 line of symbol
	ADD #100, R0		;move to next line (skip 64(040) bytes)
	DEC R1
	TST R1
	BNE Sfor
	
	;Change to next symbol
	INC R3			;Add to x
	CMP R3, #40		;Check for overflow in x
	BNE Send		;If we got overflow, move to next line
	INC R4			;Move to the next line
	CLR R3			;And move carry to the beginning of line
	CMP R4, #20		;Check for overflow in y
	BNE Send		;If we got overflow, move to the beginning
	CLR R4
Send:	RTS PC
